:skupper-name: Skupper
:skupper_cli_release: 0.2.0
:west-cluster: Managed Integration
:west-namespace: pass:q[*{walkthrough-namespace}*]
:west-cli: oc
:east-cluster: CodeReady Containers
:east-namespace: pass:q[*crc*]
:east-docs-link: https://code-ready.github.io/crc/
:east-cli: oc

= Communicating with another cluster using Skupper

Securely enable communications across OpenShift clusters.


This Solution Pattern uses an HTTP Hello World application with a frontend service and a backend service.  
The frontend uses the backend to process requests.
The frontend is deployed in the {west-namespace} namespace of the {west-cluster} cluster, and the backend is deployed in the {east-namespace} namespace of a {east-cluster} cluster.

image::https://skupper.io/images/hello-world-entities.svg[]

While these instructions use this particular application for demonstration purposes, the steps are the same for any {skupper-name}
deployment.

.Prerequisites

You must have `oc` installed

This Solution Pattern assumes you have link:{east-docs-link}[east-cluster] installed and running.  

However, {skupper-name} works with any flavor of Kubernetes.  

[type=walkthroughResource]
.{skupper-name}
****
* https://github.com/skupperproject/skupper-example-hello-world[HTTP Hello World example code]
* https://github.com/skupperproject/skupper-example-tcp-echo[TCP-based service example code]
* link:https://skupper.io/examples/index.html[Explore the examples]
****

[type=walkthroughResource,serviceName=openshift]
.Red Hat OpenShift
****
* link:{openshift-host}/console[Console, window="_blank"]
* link:https://help.openshift.com/[Openshift Online Help Center, window="_blank"]
* link:https://blog.openshift.com/[Openshift Blog, window="_blank"]
****
:sectnums:

[time=5]
== Install the {skupper-name} command-line tool in your environment

The `skupper` command-line tool is the primary entrypoint for
installing and configuring the {skupper-name} infrastructure. 

=== Download and extract the command

To get the latest release of the {skupper-name} command for your platform,
download it from GitHub and extract the executable using `tar` or
`unzip`.

Linux

 curl -fL https://github.com/skupperproject/skupper-cli/releases/download/{skupper_cli_release}/skupper-cli-{skupper_cli_release}-linux-amd64.tgz | tar -xzf -

macOS

 curl -fL https://github.com/skupperproject/skupper-cli/releases/download/{skupper_cli_release}/skupper-cli-{skupper_cli_release}-mac-amd64.tgz | tar -xzf -

This produces an executable file named `skupper` in your current
directory.

See the https://github.com/skupperproject/skupper-cli/releases[{skupper-name} CLI release
page] to get
artifacts for other platforms.

=== Place the command on your path

The subsequent steps assume `skupper` is on your path.  As an example,
this is how you might install it in your home directory:

 mkdir -p $HOME/bin
 export PATH=$PATH:$HOME/bin
 mv skupper $HOME/bin

=== Check the command

To test your installation, run the `skupper --version` command.  You
should see output like this:

 $ skupper --version
 skupper version {skupper_cli_release}

[time=5]
== Configure access to multiple namespaces

{skupper-name} is designed for use with multiple namespaces, typically on
different clusters.  The `skupper` command uses your kubeconfig and
current context to select the namespace where it operates.

=== Configure separate terminal sessions

Start a terminal session for each of your namespaces.  Set the
`KUBECONFIG` environment variable to a different path in each session.

. Start a terminal for the {west-cluster}:

 export KUBECONFIG=$HOME/.kube/config-west

. Start a terminal for the {east-cluster}

 export KUBECONFIG=$HOME/.kube/config-east

=== Log in to your clusters


. Log into the {west-cluster}.

.. Navigate to the link:{openshift-host}/console[OpenShift Console, window="_blank"]

.. Choose *Copy Login Command* from the menu displayed when you click on your username.

.. Enter the command into the {west-cluster} terminal session.

. Log into the {east-cluster}.

.. Start {east-cluster}.

 $ crc start

.. Start the {east-cluster} using the command displayed in the output, for example:

 $ oc login -u developer -p developer https://api.crc.testing:6443


=== Set the current namespaces

. In the terminal for the {west-cluster}:
+
[subs="attributes+"]
----
{west-cli} config set-context --current --namespace {west-namespace}
----

. In the terminal for the {east-cluster}:
+
[subs="attributes+"]
----
{east-cli} new-project {east-namespace}
{east-cli} config set-context --current --namespace {east-namespace}
----

[type=verification]
****
Check your configurations

Once you have logged in and set the current namespaces, use the
`skupper status` command to check that each namespace is correctly
configured.

. In the terminal for the {west-cluster}:
+
 $ skupper status
 skupper not enabled for {west-namespace}

. In the terminal for the {east-cluster}:
+
 $ skupper status
 skupper not enabled for {east-namespace}

****


[time=5]
== Install the {skupper-name} router in each namespace

The `skupper init` command installs the {skupper-name} router in the current
namespace.

=== Install the router in both namespaces

. In the terminal for the {west-cluster}:
+
[subs="attributes+"]
----
 $ skupper init
 {skupper-name} is now installed in namespace '{west-namespace}'.  Use 'skupper status' to get more information.
----

. In the terminal for the {east-cluster}:
+
[subs="attributes+"]
----
 $ skupper init --edge
 {skupper-name} is now installed in namespace '{east-namespace}'.  Use 'skupper status' to get more information.
----

Using the `--edge` argument in the {east-namespace} namespace disables network ingress at the
{skupper-name} router layer. 


[time=5]
== Connect your namespaces

Connecting namespaces requires you use the following commands:

* The `skupper connection-token` command generates a secret token that
signifies permission to connect.  The token also carries the
connection details.  

* The `skupper connect` command then uses the
connection token to establish a connection to the namespace that
generated it.

NOTE: Anyone who has the connection token can connect to your namespace.  Make sure that only those
you trust have access to it.

. Generate a
token in the {west-namespace}
+
 skupper connection-token $HOME/secret.yaml

. Use the token in the {east-namespace} to form a connection
+
 skupper connect $HOME/secret.yaml


=== Check the connection

Use the `skupper status` command again to see if things have changed.
If the connection is made, you should see the following output:

West

 $ skupper status
 {skupper-name} enabled for namespace 'west'. It is connected to 1 other site.

East

 $ skupper status
 {skupper-name} enabled for namespace 'east'. It is connected to 1 other site.

[time=5]
== Expose your services

You now have a {skupper-name} network capable of multi-cluster communication,
but no services are attached to it.  This step uses the `skupper
expose` command to make a Kubernetes deployment on one namespace
available on all the connected namespaces.

In the examples below, we use the Hello World application to
demonstrate service exposure.  The same steps apply for your own
application.

=== Deploy the frontend and backend services

Use `kubectl create deployment` to start the frontend in West.

West

 kubectl create deployment hello-world-frontend --image quay.io/skupper/hello-world-frontend

Likewise, use `kubectl create deployment` to start the backend in
East.

East

 kubectl create deployment hello-world-backend --image quay.io/skupper/hello-world-backend

=== Expose the backend service

At this point, we have the frontend and backend services running, but
the frontend has no way to contact the backend.  The frontend and
backend are in different namespaces (and perhaps different clusters),
and the backend has no public ingress.

Use the `skupper expose` command in East to make `hello-world-backend`
available in West.

East

 skupper expose deployment hello-world-backend --port 8080 --protocol http

=== Check the backend service

Use `kubectl get services` in West to make sure the
`hello-world-backend` service from East is represented.  You should
see output like this (along with some other services):

West

 $ kubectl get services
 NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)       AGE
 hello-world-backend    ClusterIP      10.96.175.18    <none>          8080/TCP      1m30s

=== Test your application

To test our Hello World, we need external access to the frontend (not
the backend).  Use `kubectl expose` with `--type LoadBalancer` to make
the frontend accessible using a conventional Kubernetes ingress.

West

 kubectl expose deployment hello-world-frontend --port 8080 --type LoadBalancer

It takes a moment for the external IP to become available.  If you are
using Minikube, link:minikube.html#prerequisites[you need to run `minikube
tunnel`] for this to work.

Now use `curl` to see it in action.  The embedded `kubectl get`
command below looks up the IP address for the frontend service and
generates a URL for use with `curl`.

West

 curl $(kubectl get service hello-world-frontend -o jsonpath='http://{.status.loadBalancer.ingress[0].ip}:8080/')

NOTE: If the embedded `kubectl get` command fails to get the IP,
you can find it manually by running `kubectl get services` and looking
up the external IP of the `hello-world-frontend` service.

You should see output like this:

 I am the frontend.  The backend says 'Hello from hello-world-backend-869cd94f69-wh6zt (1)'.

=== Summary

Our simple HTTP application has two services.  We deployed each
service to a different Kubernetes cluster.

Ordinarily, a multi-cluster deployment of this sort means that the
services have no way to communicate unless they are exposed to the
public internet.

By introducing {skupper-name} into each namespace, we were able to create a
virtual application network that connects the services across cluster
boundaries.

See the https://github.com/skupperproject/skupper-example-hello-world/blob/master/README.md#what-just-happened[Hello World
example]
for more detail.


== Cleaning up

To remove {skupper-name} and the other resources from this exercise, use
the following commands:

West

 skupper delete
 kubectl delete service/hello-world-frontend
 kubectl delete deployment/hello-world-frontend

East

 skupper delete
 kubectl delete deployment/hello-world-backend



[type=verification]
====
Did it work?
====

[type=verificationFail]
Try the steps again. If it's still not working contact your administrator.
